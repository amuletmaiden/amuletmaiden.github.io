<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Host – Preloaded Remote Audio Control</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #022c22; /* dark green */
        color: #e5e7eb;
      }
      .app {
        max-width: 860px;
        margin: 0 auto;
        padding: 24px 16px 40px;
      }
      h1 {
        font-size: 1.8rem;
        margin-bottom: 4px;
        color: #bbf7d0; /* light green */
      }
      .subtitle {
        opacity: 0.8;
        margin-bottom: 18px;
        font-size: 0.95rem;
      }
      .card {
        background: rgba(3, 24, 20, 0.95);
        border-radius: 18px;
        border: 1px solid rgba(52, 211, 153, 0.6);
        padding: 16px 18px;
        margin-bottom: 16px;
        box-shadow: 0 18px 40px rgba(3, 24, 20, 0.9);
      }
      .card h2 {
        margin-top: 0;
        font-size: 1.1rem;
        color: #6ee7b7;
      }
      label {
        font-size: 0.9rem;
        margin-bottom: 4px;
        display: block;
      }
      input[type="text"] {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(52, 211, 153, 0.8);
        background: rgba(3, 24, 20, 0.95);
        color: #e5e7eb;
        font-family: inherit;
        font-size: 0.95rem;
      }
      button {
        font-family: inherit;
        border-radius: 999px;
        border: 1px solid rgba(52, 211, 153, 0.9);
        background: rgba(5, 46, 34, 0.95);
        color: #e5e7eb;
        padding: 7px 16px;
        font-size: 0.9rem;
        cursor: pointer;
        transition:
          border-color 0.15s ease,
          transform 0.05s ease,
          background 0.15s ease;
      }
      button:hover:not(:disabled) {
        border-color: #22c55e;
        background: rgba(6, 78, 59, 0.98);
        transform: translateY(-1px);
      }
      button:disabled {
        opacity: 0.4;
        cursor: default;
        transform: none;
      }
      .button-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
      }
      .status {
        font-size: 0.85rem;
        opacity: 0.9;
        margin-top: 6px;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 0.8rem;
        border: 1px solid rgba(52, 211, 153, 0.8);
        gap: 6px;
      }
      .pill-dot {
        width: 7px;
        height: 7px;
        border-radius: 999px;
        background: #ef4444;
      }
      .pill-dot.online {
        background: #22c55e;
      }
      .small {
        font-size: 0.8rem;
        opacity: 0.75;
      }
      .track-list {
        margin-top: 10px;
        border-radius: 14px;
        border: 1px solid rgba(52, 211, 153, 0.55);
        overflow: hidden;
      }
      .track-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 10px;
        font-size: 0.9rem;
        border-bottom: 1px solid rgba(5, 30, 24, 0.9);
      }
      .track-row:last-child {
        border-bottom: none;
      }
      .track-main {
        display: flex;
        flex-direction: column;
        gap: 3px;
        max-width: 70%;
      }
      .track-name-line {
        display: flex;
        align-items: center;
        gap: 6px;
        min-width: 0;
      }
      .track-name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
      }
      .track-badge {
        font-size: 0.75rem;
        text-transform: uppercase;
        border-radius: 999px;
        border: 1px solid rgba(52, 211, 153, 0.9);
        padding: 2px 8px;
        margin-right: 2px;
      }
      .track-badge.active {
        border-color: #22c55e;
        color: #bbf7d0;
      }
      .track-time {
        font-size: 0.8rem;
        opacity: 0.9;
        cursor: text;
        padding: 1px 4px;
        border-radius: 6px;
        align-self: flex-start;
      }
      .track-time:hover {
        background: rgba(21, 128, 61, 0.35);
      }
      .time-input {
        width: 70px;
        padding: 2px 4px;
        border-radius: 6px;
        border: 1px solid rgba(52, 211, 153, 0.9);
        background: rgba(3, 24, 20, 0.95);
        color: #e5e7eb;
        font-size: 0.8rem;
      }
      #listener-link {
        font-size: 0.9rem;
        word-break: break-all;
        margin-top: 6px;
      }
      .highlight {
        color: #6ee7b7;
      }
      .select-list {
        margin-top: 10px;
        border-radius: 14px;
        border: 1px solid rgba(52, 211, 153, 0.55);
        max-height: 260px;
        overflow-y: auto;
      }
      .select-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px 8px;
        border-bottom: 1px solid rgba(5, 30, 24, 0.9);
        font-size: 0.9rem;
      }
      .select-row:last-child {
        border-bottom: none;
      }
      .select-left {
        display: flex;
        align-items: center;
        gap: 6px;
        max-width: 60%;
      }
      .filename {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .label-input {
        width: 40%;
        min-width: 120px;
        padding: 4px 6px;
        border-radius: 8px;
        border: 1px solid rgba(52, 211, 153, 0.7);
        background: rgba(3, 24, 20, 0.95);
        color: #e5e7eb;
        font-size: 0.85rem;
      }
      .seek-row {
        display: flex;
        gap: 8px;
        margin-top: 4px;
        align-items: center;
      }
      input[type="range"] {
        flex: 1;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <h1>Host – Preloaded Remote Audio Control</h1>
      <div class="subtitle">
        Your listener’s browser buffers your files from this site. You, the
        mistress, choose which track and position they hear.
      </div>

      <!-- ROOM SETUP -->
      <section class="card">
        <h2>1. Choose a room ID</h2>
        <label for="room-id">Room ID</label>
        <input
          id="room-id"
          type="text"
          placeholder="e.g. client-001"
          autocomplete="off"
        />
        <div class="button-row" style="margin-top: 10px">
          <button id="btn-start-host">Start hosting</button>
        </div>
        <div class="status" id="host-setup-status">
          Pick a simple ID you can tell your listener (“client-001” etc.).
        </div>
      </section>

      <!-- TRACK LIST DEFINITION -->
      <section class="card" id="tracks-card" style="display: none">
        <h2>2. Choose tracks from your <code>audio/</code> folder</h2>
        <div class="status small" id="files-status">
          Files are loaded from your public GitHub repo
          <code>amuletmaiden/amuletmaiden.github.io/audio/</code>.
        </div>

        <div class="button-row" style="margin-top: 8px">
          <button id="btn-refresh-files">Reload from audio/</button>
          <button id="btn-select-all">Select all</button>
          <button id="btn-clear-selection">Clear</button>
        </div>

        <div
          id="available-tracks-list"
          class="select-list"
          style="margin-top: 10px"
        ></div>

        <div class="button-row" style="margin-top: 12px">
          <button id="btn-send-tracks">Send selected tracks to listeners</button>
        </div>
      </section>

      <!-- CONNECTION / LINK -->
      <section class="card" id="room-info" style="display: none">
        <h2>3. Send this link to your listener</h2>
        <div class="status">
          Connection:
          <span class="pill">
            <span class="pill-dot" id="host-conn-dot"></span>
            <span id="host-conn-text">Not connected</span>
          </span>
        </div>
        <div id="listener-link" class="status">
          Listener link will appear here once hosting is ready.
        </div>
      </section>

      <!-- PLAYBACK CONTROL -->
      <section class="card" id="control-card" style="display: none">
        <h2>4. Control playback</h2>

        <div class="status">
          <strong>Status:</strong>
          <span id="ready-status">Tracks not loaded yet.</span>
        </div>

        <div class="button-row" style="margin-top: 10px">
          <button id="btn-play" disabled>Play</button>
          <button id="btn-pause" disabled>Pause</button>
          <button id="btn-toggle-loop" disabled>Loop: Off</button>
        </div>

        <div class="status" style="margin-top: 12px">
          <label for="volume-input">Listener volume</label>
          <div class="seek-row">
            <input
              id="volume-input"
              type="range"
              min="0"
              max="100"
              value="100"
            />
            <span class="small" id="volume-label">100%</span>
          </div>
        </div>

        <div class="status" style="margin-top: 12px">
          <label for="seek-input">Jump all tracks to time (mm:ss or seconds)</label>
          <div class="seek-row">
            <input
              id="seek-input"
              type="text"
              placeholder="e.g. 1:30 or 90"
            />
            <button id="btn-seek" disabled>Jump</button>
          </div>
          <div class="status small" id="seek-hint"></div>
        </div>

        <div class="status" style="margin-top: 10px">
          <strong>Active track:</strong>
          <span id="active-track-label">none</span>
        </div>

        <div id="track-list" class="track-list" style="display: none"></div>

        <div class="status" id="host-status" style="margin-top: 10px"></div>
      </section>
    </div>

    <!-- Firebase compat builds -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>

    <script>
      // === YOUR FIREBASE CONFIG ====================================
      const firebaseConfig = {
        apiKey: "AIzaSyCPHd62hm96T9kcy1ZqWUhFu1WN8A0Mwj4",
        authDomain: "audio-8c1f6.firebaseapp.com",
        databaseURL: "https://audio-8c1f6-default-rtdb.firebaseio.com",
        projectId: "audio-8c1f6",
        storageBucket: "audio-8c1f6.firebasestorage.app",
        messagingSenderId: "313094779274",
        appId: "1:313094779274:web:8394e80c777f11fd6e9873"
      };
      // ============================================================

      firebase.initializeApp(firebaseConfig);
      const db = firebase.database();

      // UI elements
      const roomInput = document.getElementById("room-id");
      const btnStartHost = document.getElementById("btn-start-host");
      const hostSetupStatus = document.getElementById("host-setup-status");

      const tracksCard = document.getElementById("tracks-card");
      const filesStatus = document.getElementById("files-status");
      const btnRefreshFiles =
        document.getElementById("btn-refresh-files");
      const btnSelectAll =
        document.getElementById("btn-select-all");
      const btnClearSelection =
        document.getElementById("btn-clear-selection");
      const availableTracksList =
        document.getElementById("available-tracks-list");
      const btnSendTracks =
        document.getElementById("btn-send-tracks");

      const roomInfo = document.getElementById("room-info");
      const hostConnDot = document.getElementById("host-conn-dot");
      const hostConnText = document.getElementById("host-conn-text");
      const listenerLinkEl = document.getElementById("listener-link");

      const controlCard = document.getElementById("control-card");
      const readyStatus = document.getElementById("ready-status");
      const btnPlay = document.getElementById("btn-play");
      const btnPause = document.getElementById("btn-pause");
      const btnToggleLoop =
        document.getElementById("btn-toggle-loop");
      const seekInput = document.getElementById("seek-input");
      const btnSeek = document.getElementById("btn-seek");
      const seekHint = document.getElementById("seek-hint");
      const trackListEl = document.getElementById("track-list");
      const activeTrackLabel =
        document.getElementById("active-track-label");
      const hostStatus = document.getElementById("host-status");

      const volumeInput =
        document.getElementById("volume-input");
      const volumeLabel =
        document.getElementById("volume-label");

      // State
      let currentRoomId = null;
      let roomRef = null;

      let availableFiles = []; // { name }
      let tracks = []; // { id, filename, label }
      const audioMap = {}; // id -> HTMLAudioElement
      const readyMap = {}; // id -> boolean
      const durationMap = {}; // id -> number
      const timeDisplayMap = {}; // id -> span
      let readyCount = 0;

      let currentState = {
        activeTrackId: null,
        playing: false,
        loop: false,
        seekTo: null,
        seekVersion: 0,
        volume: 1,
        livePosition: 0
      };
      let lastSeekVersionApplied = 0;
      let lastLiveUpdateMs = 0;

      function setHostConnectionStatus(online) {
        if (online) {
          hostConnDot.classList.add("online");
          hostConnText.textContent = "Hosting room";
        } else {
          hostConnDot.classList.remove("online");
          hostConnText.textContent = "Not connected";
        }
      }

      function randomId() {
        return (
          Date.now().toString(36) +
          "-" +
          Math.random().toString(36).slice(2)
        );
      }

      function getAudioBaseUrl() {
        return window.location.origin + "/audio/";
      }

      function formatTime(seconds) {
        seconds = Math.max(0, Math.floor(seconds));
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return m + ":" + (s < 10 ? "0" + s : s);
      }

      function parseTimeInput(text) {
        if (!text) return null;
        const t = text.trim();
        if (!t) return null;
        if (t.includes(":")) {
          const parts = t.split(":");
          if (parts.length !== 2) return null;
          const m = parseFloat(parts[0]);
          const s = parseFloat(parts[1]);
          if (isNaN(m) || isNaN(s)) return null;
          return m * 60 + s;
        } else {
          const s = parseFloat(t);
          if (isNaN(s)) return null;
          return s;
        }
      }

      function updateLoopButton() {
        btnToggleLoop.textContent = currentState.loop
          ? "Loop: On"
          : "Loop: Off";
      }

      function updateVolumeLabel(vol) {
        if (!volumeLabel) return;
        const clamped = Math.max(
          0,
          Math.min(1, typeof vol === "number" ? vol : 1)
        );
        volumeLabel.textContent =
          Math.round(clamped * 100) + "%";
      }

      function updateVolumeUI(vol) {
        if (!volumeInput) return;
        const clamped = Math.max(
          0,
          Math.min(1, typeof vol === "number" ? vol : 1)
        );
        volumeInput.value = String(Math.round(clamped * 100));
        updateVolumeLabel(clamped);
      }

      function updateTimeDisplay(trackId) {
        const audio = audioMap[trackId];
        const span = timeDisplayMap[trackId];
        if (!audio || !span) return;
        const cur = isFinite(audio.currentTime)
          ? audio.currentTime
          : 0;
        const dur = isFinite(audio.duration)
          ? audio.duration
          : durationMap[trackId] || null;
        if (dur && isFinite(dur)) {
          span.textContent =
            formatTime(cur) + " / " + formatTime(dur);
        } else {
          span.textContent = formatTime(cur);
        }
      }

      function maybeSendLivePosition(trackId) {
        if (!roomRef) return;
        if (!currentState.playing) return;
        if (trackId !== currentState.activeTrackId) return;
        const audio = audioMap[trackId];
        if (!audio) return;
        const now = Date.now();
        if (now - lastLiveUpdateMs < 1000) return; // throttle ~1s
        lastLiveUpdateMs = now;
        const pos = isFinite(audio.currentTime)
          ? audio.currentTime
          : 0;
        currentState.livePosition = pos;
        roomRef.child("state").update({ livePosition: pos });
      }

      function enableEditingTime(trackId, span) {
        const audio = audioMap[trackId];
        if (!audio) return;
        const oldText = span.textContent;
        const input = document.createElement("input");
        input.type = "text";
        input.className = "time-input";
        input.value = formatTime(audio.currentTime || 0);
        span.textContent = "";
        span.appendChild(input);
        input.focus();
        input.select();

        const finish = (apply) => {
          const val = input.value;
          span.removeChild(input);
          if (apply) {
            const seconds = parseTimeInput(val);
            if (seconds !== null && seconds >= 0) {
              try {
                audio.currentTime = seconds;
              } catch (e) {}
              updateTimeDisplay(trackId);
              if (trackId === currentState.activeTrackId && roomRef) {
                currentState.seekVersion =
                  (currentState.seekVersion || 0) + 1;
                currentState.seekTo = seconds;
                lastSeekVersionApplied =
                  currentState.seekVersion;
                currentState.livePosition = seconds;
                roomRef.child("state").update({
                  seekTo: seconds,
                  seekVersion: currentState.seekVersion,
                  livePosition: seconds
                });
              }
              return;
            }
          }
          span.textContent = oldText;
        };

        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            finish(true);
          } else if (e.key === "Escape") {
            e.preventDefault();
            finish(false);
          }
        });
        input.addEventListener("blur", () => finish(true));
      }

      btnStartHost.addEventListener("click", async () => {
        const roomId = roomInput.value.trim();
        if (!roomId) {
          alert("Please enter a room ID first.");
          return;
        }
        currentRoomId = roomId;
        await startHost(roomId);
      });

      btnRefreshFiles.addEventListener("click", () => {
        autoLoadAudioFiles();
      });

      btnSelectAll.addEventListener("click", () => {
        availableTracksList
          .querySelectorAll('input[type="checkbox"]')
          .forEach((cb) => (cb.checked = true));
      });

      btnClearSelection.addEventListener("click", () => {
        availableTracksList
          .querySelectorAll('input[type="checkbox"]')
          .forEach((cb) => (cb.checked = false));
      });

      if (volumeInput) {
        volumeInput.addEventListener("input", () => {
          const raw = parseInt(volumeInput.value, 10);
          const vol = isNaN(raw)
            ? 1
            : Math.max(0, Math.min(1, raw / 100));
          currentState.volume = vol;
          if (roomRef) {
            roomRef.child("state").update({
              volume: vol
            });
          }
          updateVolumeLabel(vol);
          applyPlaybackState();
        });
      }

      btnSendTracks.addEventListener("click", async () => {
        const rows =
          availableTracksList.querySelectorAll(".select-row");
        const chosen = [];
        rows.forEach((row) => {
          const cb = row.querySelector('input[type="checkbox"]');
          if (!cb || !cb.checked) return;
          const filename = cb.dataset.filename;
          const labelInput =
            row.querySelector(".label-input");
          const label =
            (labelInput && labelInput.value.trim()) || filename;
          chosen.push({ filename, label });
        });
        if (!chosen.length) {
          alert("Select at least one track.");
          return;
        }

        tracks = chosen.map((item) => ({
          id: randomId(),
          filename: item.filename,
          label: item.label
        }));

        const tracksObj = {};
        tracks.forEach((t) => {
          tracksObj[t.id] = {
            filename: t.filename,
            label: t.label
          };
        });

        await roomRef.child("tracks").set(tracksObj);

        prepareLocalAudio(tracks);

        controlCard.style.display = "block";
        renderTrackList();
        hostStatus.textContent =
          "Track list sent. Waiting for buffers to fill.";
      });

      btnToggleLoop.addEventListener("click", () => {
        currentState.loop = !currentState.loop;
        updateLoopButton();
        if (roomRef) {
          roomRef.child("state").update({
            loop: currentState.loop
          });
        }
        applyPlaybackState();
      });

      btnSeek.addEventListener("click", () => {
        const value = seekInput.value;
        const seconds = parseTimeInput(value);
        if (seconds === null || seconds < 0) {
          alert("Enter a time like 1:30 or 90");
          return;
        }
        currentState.seekVersion =
          (currentState.seekVersion || 0) + 1;
        currentState.seekTo = seconds;
        lastSeekVersionApplied = currentState.seekVersion;
        currentState.livePosition = seconds;

        tracks.forEach((track) => {
          const audio = audioMap[track.id];
          if (!audio) return;
          try {
            audio.currentTime = seconds;
          } catch (e) {}
        });

        if (roomRef) {
          roomRef.child("state").update({
            seekTo: seconds,
            seekVersion: currentState.seekVersion,
            livePosition: seconds
          });
        }

        seekHint.textContent =
          "Jumped to " + formatTime(seconds) + " in all tracks.";
        applyPlaybackState();
      });

      async function startHost(roomId) {
        setHostConnectionStatus(false);
        hostSetupStatus.textContent = "Connecting as host…";

        roomRef = db.ref("rooms").child(roomId);

        await roomRef.child("host").set({
          online: true,
          ts: firebase.database.ServerValue.TIMESTAMP
        });
        roomRef
          .child("host")
          .onDisconnect()
          .remove()
          .catch(() => {});

        roomRef.child("state").update({
          volume: currentState.volume
        });

        const listenerUrl =
          window.location.origin +
          "/listener.html?room=" +
          encodeURIComponent(roomId);

        roomInfo.style.display = "block";
        listenerLinkEl.innerHTML =
          'Listener link: <span class="highlight">' +
          listenerUrl +
          "</span>";
        tracksCard.style.display = "block";
        setHostConnectionStatus(true);
        hostSetupStatus.textContent =
          'Hosting room "' +
          roomId +
          '". Choose which files to send.';

        roomRef.child("state").on("value", (snap) => {
          const val = snap.val() || {};
          const incomingVersion = val.seekVersion || 0;
          const incomingSeek =
            typeof val.seekTo === "number" ? val.seekTo : null;
          const incomingVolume =
            typeof val.volume === "number"
              ? val.volume
              : currentState.volume ?? 1;
          const incomingLive =
            typeof val.livePosition === "number"
              ? val.livePosition
              : currentState.livePosition ?? 0;

          if (
            incomingSeek !== null &&
            incomingVersion > lastSeekVersionApplied
          ) {
            lastSeekVersionApplied = incomingVersion;
            tracks.forEach((track) => {
              const audio = audioMap[track.id];
              if (!audio) return;
              try {
                audio.currentTime = incomingSeek;
              } catch (e) {}
            });
          }

          currentState = {
            activeTrackId: val.activeTrackId || null,
            playing: !!val.playing,
            loop: !!val.loop,
            seekTo: incomingSeek,
            seekVersion: incomingVersion,
            volume: incomingVolume,
            livePosition: incomingLive
          };
          updateLoopButton();
          updateVolumeUI(incomingVolume);
          applyPlaybackState();
        });

        autoLoadAudioFiles();
      }

      async function autoLoadAudioFiles() {
        const url =
          "https://api.github.com/repos/amuletmaiden/amuletmaiden.github.io/contents/audio";
        filesStatus.textContent =
          "Loading audio/ from GitHub…";
        availableTracksList.innerHTML = "";
        try {
          const res = await fetch(url);
          if (!res.ok) {
            throw new Error("HTTP " + res.status);
          }
          const data = await res.json();
          availableFiles = (data || []).filter(
            (item) =>
              item.type === "file" &&
              /\.(mp3|wav|ogg|m4a)$/i.test(item.name)
          );
          if (!availableFiles.length) {
            filesStatus.textContent =
              "No audio files found in audio/. Add some to the repo and reload.";
            return;
          }
          filesStatus.textContent =
            "Loaded " +
            availableFiles.length +
            " file(s) from audio/. Check the ones you want to send.";
          renderAvailableFiles();
        } catch (e) {
          filesStatus.textContent =
            "Could not load audio/ automatically. Check your repo name or try again.";
        }
      }

      function renderAvailableFiles() {
        availableTracksList.innerHTML = "";
        availableFiles.forEach((file) => {
          const row = document.createElement("div");
          row.className = "select-row";

          const left = document.createElement("label");
          left.className = "select-left";

          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.checked = true;
          cb.dataset.filename = file.name;

          const nameSpan = document.createElement("span");
          nameSpan.className = "filename";
          nameSpan.textContent = file.name;

          left.appendChild(cb);
          left.appendChild(nameSpan);

          const labelInput = document.createElement("input");
          labelInput.type = "text";
          labelInput.className = "label-input";
          labelInput.value = file.name;
          labelInput.placeholder = "Label (optional)";

          row.appendChild(left);
          row.appendChild(labelInput);

          availableTracksList.appendChild(row);
        });
      }

      function prepareLocalAudio(trackList) {
        const base = getAudioBaseUrl();
        readyCount = 0;
        for (const id in readyMap) {
          delete readyMap[id];
        }
        for (const id in durationMap) {
          delete durationMap[id];
        }

        trackList.forEach((track) => {
          const url = base + track.filename;
          let audio = audioMap[track.id];
          if (!audio) {
            audio = new Audio();
            audioMap[track.id] = audio;
            audio.preload = "auto";
            audio.setAttribute("playsinline", "");
            audio.addEventListener("canplaythrough", () => {
              if (!readyMap[track.id]) {
                readyMap[track.id] = true;
                readyCount++;
                updateReadyStatus();
              }
            });
            audio.addEventListener("loadedmetadata", () => {
              if (isFinite(audio.duration)) {
                durationMap[track.id] = audio.duration;
              }
              updateTimeDisplay(track.id);
            });
            audio.addEventListener("timeupdate", () => {
              updateTimeDisplay(track.id);
              maybeSendLivePosition(track.id);
            });
            audio.addEventListener("error", () => {
              hostStatus.textContent =
                "Error loading " +
                track.filename +
                ". Check that it exists in audio/ and is accessible.";
            });
          }
          audio.src = url;
          audio.load();
        });
        updateReadyStatus();
      }

      function updateReadyStatus() {
        const total = tracks.length;
        if (!total) {
          readyStatus.textContent = "No tracks selected yet.";
          btnPlay.disabled = true;
          btnPause.disabled = true;
          btnToggleLoop.disabled = true;
          btnSeek.disabled = true;
          if (volumeInput) volumeInput.disabled = true;
          return;
        }
        readyStatus.textContent =
          "Buffered tracks (host side): " + readyCount + " / " + total;
        const anyReady = Object.values(readyMap).some(Boolean);
        btnPlay.disabled = !anyReady;
        btnPause.disabled = !anyReady;
        btnToggleLoop.disabled = !anyReady;
        btnSeek.disabled = !anyReady;
        if (volumeInput) volumeInput.disabled = !anyReady;
      }

      function renderTrackList() {
        trackListEl.innerHTML = "";
        for (const id in timeDisplayMap) {
          delete timeDisplayMap[id];
        }

        if (!tracks.length) {
          trackListEl.style.display = "none";
          activeTrackLabel.textContent = "none";
          return;
        }
        trackListEl.style.display = "block";

        tracks.forEach((track) => {
          const row = document.createElement("div");
          row.className = "track-row";

          const main = document.createElement("div");
          main.className = "track-main";

          const nameLine = document.createElement("div");
          nameLine.className = "track-name-line";

          const badge = document.createElement("span");
          badge.className = "track-badge";
          if (track.id === currentState.activeTrackId) {
            badge.classList.add("active");
            badge.textContent = "Active";
          } else {
            badge.textContent = "Idle";
          }

          const nameSpan = document.createElement("span");
          nameSpan.className = "track-name";
          nameSpan.textContent = track.label;

          nameLine.appendChild(badge);
          nameLine.appendChild(nameSpan);

          const timeSpan = document.createElement("span");
          timeSpan.className = "track-time";
          timeSpan.textContent = "0:00";
          timeDisplayMap[track.id] = timeSpan;
          timeSpan.addEventListener("click", () =>
            enableEditingTime(track.id, timeSpan)
          );

          main.appendChild(nameLine);
          main.appendChild(timeSpan);

          const switchBtn = document.createElement("button");
          switchBtn.textContent = "Make active";
          switchBtn.addEventListener("click", () => {
            setActiveTrack(track.id);
          });

          row.appendChild(main);
          row.appendChild(switchBtn);

          trackListEl.appendChild(row);

          updateTimeDisplay(track.id);
        });

        const active = tracks.find(
          (t) => t.id === currentState.activeTrackId
        );
        activeTrackLabel.textContent = active
          ? active.label
          : "none";
      }

      function setActiveTrack(id) {
        if (!tracks.find((t) => t.id === id)) return;
        currentState.activeTrackId = id;
        const audio = audioMap[id];
        if (audio && isFinite(audio.currentTime)) {
          currentState.livePosition = audio.currentTime;
          if (roomRef) {
            roomRef.child("state").update({
              activeTrackId: id,
              livePosition: audio.currentTime,
              playing: currentState.playing
            });
          }
        } else if (roomRef) {
          roomRef.child("state").update({
            activeTrackId: id,
            playing: currentState.playing
          });
        }

        renderTrackList();
        if (currentState.playing) {
          hostStatus.textContent =
            "Switched active track. Listener should hear it immediately.";
        } else {
          hostStatus.textContent =
            "Active track changed. Will play when you press Play.";
        }
      }

      btnPlay.addEventListener("click", () => {
        if (!tracks.length) return;
        if (!currentState.activeTrackId) {
          currentState.activeTrackId = tracks[0].id;
        }

        const audio =
          audioMap[currentState.activeTrackId] || null;
        if (audio && isFinite(audio.currentTime)) {
          currentState.livePosition = audio.currentTime;
        }

        currentState.playing = true;
        if (roomRef) {
          roomRef.child("state").update({
            activeTrackId: currentState.activeTrackId,
            playing: true,
            livePosition: currentState.livePosition
          });
        }
        hostStatus.textContent =
          "Play command sent. Listener will start playback.";
        renderTrackList();
        applyPlaybackState();
      });

      btnPause.addEventListener("click", () => {
        const audio =
          currentState.activeTrackId &&
          audioMap[currentState.activeTrackId]
            ? audioMap[currentState.activeTrackId]
            : null;
        if (audio && isFinite(audio.currentTime)) {
          currentState.livePosition = audio.currentTime;
        }

        currentState.playing = false;
        if (roomRef) {
          roomRef.child("state").update({
            playing: false,
            livePosition: currentState.livePosition
          });
        }
        hostStatus.textContent =
          "Pause command sent. Listener will stop playback.";
        applyPlaybackState();
      });

      function applyPlaybackState() {
        const { activeTrackId, playing, loop, volume } = currentState;
        const vol =
          typeof volume === "number"
            ? Math.max(0, Math.min(1, volume))
            : 1;
        tracks.forEach((track) => {
          const audio = audioMap[track.id];
          if (!audio) return;
          audio.loop = !!loop;
          audio.volume = vol;
          if (
            playing &&
            track.id === activeTrackId &&
            readyMap[track.id]
          ) {
            audio.play().catch(() => {});
          } else {
            audio.pause();
          }
        });
        renderTrackList();
      }

      document.addEventListener("visibilitychange", () => {
        if (!document.hidden && currentState.playing) {
          applyPlaybackState();
        }
      });

      updateVolumeUI(currentState.volume);
    </script>
  </body>
</html>
